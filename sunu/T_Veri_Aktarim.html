<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R ile Veri Analizi</title>
    <meta charset="utf-8" />
    <meta name="author" content="    ğŸ‘©â€ğŸ« Dr.Â KÃ¼bra ATALAY KABASAKAL   Hacettepe Ãœniversitesi" />
    <script src="libs/header-attrs-2.17/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="slides-style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R ile Veri Analizi
]
.subtitle[
## <br> ğŸ“‰ Veri AktarÄ±mÄ±
]
.author[
### <br> <br> ğŸ‘©â€ğŸ« Dr.Â KÃ¼bra ATALAY KABASAKAL <br> Hacettepe Ãœniversitesi
]
.date[
### <br> <br> <br> <br>ğŸ“§ <a href="mailto:katalay@hacettepe.edu.tr" class="email">katalay@hacettepe.edu.tr</a>
]

---


## Veri Okuma



- Veri giriÅŸi istatistiksel analiz surecinin ilk adÄ±mÄ±dÄ±r.

--

- R'da veri giriÅŸi diÄŸer yazÄ±lÄ±mlarla kÄ±yaslandÄ±ÄŸÄ±nda Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir. 

--

- Bu nedenle aktarma/import yolu tercih edilir.

--

- Veri aktarÄ±mÄ± iÃ§in Ã§ok sayÄ±da fonksiyon ve paket bulunmaktadÄ±r. 

--

- AyrÄ±ca menÃ¼ ile de aktarma yapÄ±labilir. 

--

- Bilgisayardan internetten farklÄ± formattaki veriler okunabilir.

---

# Veri AktarÄ±mÄ±
  
- Veri setleri genellikle Excel, SPSS veya metin dosyalarÄ± (.txt, .csv, .dat, vb.) gibi uygun veri biÃ§imlerinde kaydedilir


- R, Ã§eÅŸitli veri formatlarÄ±nÄ± iÃ§e aktarabilir (yani okuyabilir).

--

Bir veri setini R'ye aktarmanÄ±n iki yolu vardÄ±r:

--

1. RStudio'da "Veri KÃ¼mesini Ä°Ã§e Aktar" menÃ¼ seÃ§eneÄŸini kullanarak
2. Belirli bir R komutunu kullanarak

&lt;br/&gt;

---
## YÃ¶ntem 1: RStudio'yu Kullanma

  ![R studio](figs/importmenu.png)

---
### Excel dosylarÄ±nÄ± iÃ§e aktarma

* Ä°Ã§e aktarmak istediÄŸiniz dosyaya gÃ¶z atÄ±n.

* Veri seti iÃ§in bir isim verin. 

* Ä°Ã§e aktarÄ±lacak sayfayÄ± seÃ§in.

* DeÄŸiÅŸken isimleri dosyanÄ±n ilk satÄ±rÄ±ndaysa "First Row as Names".

![Excel dosylarÄ±nÄ± iÃ§e aktarma](figs/excel1.png)

---
### SPSS dosylarÄ±nÄ± iÃ§e aktarma

* Ä°Ã§e aktarmak istediÄŸiniz dosyaya gÃ¶z atÄ±n.

* Veri seti iÃ§in bir isim verin. 

![SPSS dosylarÄ±nÄ± iÃ§e aktarma](figs/spss1.png)

&lt;br/&gt;

---
## Veri Okuma

-   En temel veri okuma/aktarma fonksiyonlari

--

    -   `scan()`
    
--

    -   `read.*`
    
--

    -   `read.table()`
    
--

    -   `read.csv()`
    
--

    -   `read.csv2()`
    
--

    -   `read.delim()`
    
--

    -   `read.delim2()`
    
--

    -   `readLines()`
    
---
## Veri Okuma


--

-   Verinin dÃ¼zgÃ¼n girilmiÅŸ olmasÄ± okumayÄ± kolaylaÅŸtÄ±rÄ±r.

--

-   Ä°lk satÄ±rda genellikle deÄŸiÅŸken adlarÄ±na (header), 
ilk sÃ¼tunda ise kimlik veya sÄ±ra numarasÄ±na yer verilir.

--

-   GÃ¶zlemlere ve deÄŸiÅŸkenlere iliÅŸkin veri girilirken karakterler veya 
sayÄ±sal deÄŸerler arasÄ±nda boÅŸluk bÄ±rakmaktan kaÃ§Ä±nmak gerekmektedir.

--

-   DeÄŸiÅŸken adÄ± boÅŸluklu yazÄ±lmÄ±ÅŸsa ne olur?

---
## Veri Okuma

--


-   Eksik veri boyunca aynÄ± ÅŸekilde girilmelidir.

--


-   DeÄŸiÅŸkenlerin birinden nasÄ±l ayrÄ±ldÄ±ÄŸÄ± Ã¶nemlidir. (, ; : \ / )

--


-   Tercihimiz **.csv** uzantÄ±lÄ± veriler ama bÃ¼yÃ¼k veri setleri az yer kalmasÄ± icin **.txt,.prn** formatÄ±nda karÅŸÄ±mÄ±za Ã§Ä±kabilmektedir.

---
### Komutlarla veri aktarma
  
- Temel pakette **read.csv** ve **read.table** gibi bazÄ± fonksiyonlar bulunmaktadÄ±r.

- AyrÄ±ca, belirli  formatlarÄ±nÄ± iÃ§e aktarmak iÃ§in R paketleri bulunmaktadÄ±r.

- Ã–rneÄŸin, SPSS dosyalarÄ± iÃ§in **foreign** ve Excel dosyalarÄ± iÃ§in **xlsx** gibi

---

## read.\*() fonksiyonlari
|  **ArgÃ¼man**  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|   **AÃ§Ä±klama**	|
|:---	|:---	|
|  **header** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 	|  MantÄ±ksal deÄŸerler ile verinin ilk satÄ±rÄ±nda deÄŸiÅŸken isimlerinin olup olmadÄ±ÄŸÄ±nÄ± test eder. 	|
|  **sep**  	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  |  SÃ¼tun ayracÄ±dÄ±r.  	|
|   **na.strings** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|  KayÄ±p deÄŸerleri belirtmek iÃ§in kullanÄ±lÄ±r.  	|
|   **dec**	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  |  OndalÄ±k sayÄ±larÄ±n ne ile ayrÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶steren argÃ¼mandÄ±r.  	|
|   **nrows** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 	|  Okunmak istenilen satÄ±r sayÄ±sÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r.  	|
|   **skip**  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|  Bir dosya okunurken okunmadan atlanmak istenilen satÄ±r sayÄ±sÄ± iÃ§in kullanÄ±lÄ±r.  |



---
## Importing Excel files
  

```r
# yÃ¼kle ve aktive et 
install.packages("xlsx")
library("xlsx")

# read.xlsx fonksiyonunun kullanÄ±mÄ±
my_excel_file &lt;- read.xlsx("dizin/dosyaadi.xlsx",
                 sheetName = "sheetname")
```

---
### SPSS dosyasÄ± aktarma
  

```r
# yÃ¼kle ve aktive et 
install.packages("foreign")
library("foreign")

# read.spss fonksiyonunun kullanÄ±mÄ±
my_spss_file &lt;- read.spss("dizin/dosyaadi.sav",
                to.data.frame = TRUE)
```


---
### text dosyasÄ± aktarma

- text dosyalarÄ± okumak iÃ§in paket yÃ¼klemeye gerek yoktur.  

```r
# , ile ayrÄ±lmÄ±ÅŸ csv dosyalarÄ±
csv_dosya &lt;- read.csv("dizin/dosyaadi.csv", 
                      header = TRUE)

# tab ile ayrÄ±lmÄ±ÅŸ txt dosyalarÄ±
txt_dosya &lt;- read.table("dizin/dosyaadi.txt", h
                        header = TRUE, sep = "\t")
```

- Dikkat
  
- `header = TRUE` 
- `sep="\t"` 
- `sep=","` for comma-separated files

---
## Uygulama

- ğŸ”—[veri1.txt](import/veri1.txt)
- ğŸ”—[veri1.csv](import/veri1.csv)
- ğŸ”—[verifwf.txt](import/fwf.txt)
- ğŸ”—[factor.sav](import/factor.sav)
- ğŸ”—
[https://www.statmodel.com/usersguide/chap3/ex3.1.dat](https://www.statmodel.com/usersguide/chap3/ex3.1.dat)

---
## Uygulama



---
## Veri Yazma


```r
ad  &lt;-  c("Ali","Elif","Su","Deniz","Aras","Berk","Can","Ece","Efe","Arda")
boy &lt;- c(160,165,170,155,167,162,169,158,160,164)
kilo &lt;- c(50,55,57,50,48,65,58,62,45,47)
beden &lt;- c("S","M","S","M","S","L","M","L","S","S")
df &lt;- data.frame(ad, boy, kilo, beden)
df
```

```
##       ad boy kilo beden
## 1    Ali 160   50     S
## 2   Elif 165   55     M
## 3     Su 170   57     S
## 4  Deniz 155   50     M
## 5   Aras 167   48     S
## 6   Berk 162   65     L
## 7    Can 169   58     M
## 8    Ece 158   62     L
## 9    Efe 160   45     S
## 10  Arda 164   47     S
```

---

## write.table 

--


```r
write.table(df, file="df.txt")# df dosyasi nerede, gorunumu nasil
```

--


```r
write.table(df, file="df.txt",row.names = FALSE,col.names = FALSE)
# karakter nesnler tirnak icinde ne yapmali?
```

--


```r
write.table(df, file="df.txt",row.names = FALSE,col.names = FALSE,quote=FALSE)
```

---

## write.table 

yeni gÃ¶zlem eklemek istiyorsaniz append argÃ¼manÄ± kullanÄ±labilir.


```r
 ek &lt;- data.frame(ad=c("Ahmet","Ali"), boy=c(180,170), kilo=c(60,70), 
                 beden=c("S","L"))
```

--


```r
write.table(ek, "df.txt",row.names=FALSE,
            col.names=FALSE,
            quote=FALSE,append=TRUE)
```

---

## write.csv

**write.csv()** fonksiyonu kullanÄ±larak yazÄ±lan veri dosyalarÄ± "," ile,   **write.csv2()**  fonksiyonu kullanÄ±larak yazÄ±lan veri dosyalarÄ± ise ";" ile ayrÄ±lÄ±r  iki fonksiyonun bir diÄŸer farkÄ± ise ondalÄ±k sayÄ± ayÄ±racÄ±dÄ±r.

--

 write.csv ile yazdÄ±rÄ±lan dosyalarÄ±n excelde aÃ§Ä±lmasÄ±


---

## cat

**cat()** fonksiyonu

- DÃ¶ngÃ¼lerde sÄ±klÄ±kla ekrana bilgi yazdÄ±rmak amacÄ±yla kullanÄ±lÄ±r, ancak dosya yazdÄ±rmak amacÄ±yla da kullanabilmektedir. 
- fonksiyonlarla yapÄ±lan hesaplama Ã§Ä±ktÄ±sÄ± da yazabilmektedir. 
- Bu nedenle bir R oturumu sÄ±rasÄ±nda not alÄ±nmak istenilen bilgileri bir dosyaya yazdÄ±rmak iÃ§in kullanÄ±labilir.


```r
 cat("ogrencilerin boy ortalamasi ", mean(boy), "\n",
      "ogrencilerin kilo ortalamasi", mean(kilo), "\n",
     file="bilgi.txt")
```
 **"\n" ne ise yaradi?**
 
---
## writeLines fonksiyonu

```r
writeLines("ogrencilerin boy ortalamasi: 163 cm\n",
            "ogrencilerin kilo ortalamasi: 53.7 kg",
            con="bilgi2.txt")
```

 
---
 
## sink() fonksiyonu

- **sink()**  fonksiyonu yapÄ±lan iÅŸlemlerin Ã§Ä±ktÄ±sÄ±nÄ± R konsola deÄŸil belirtilen dosyaya yazmaktadÄ±r. Bu fonksiyon Ã¶zellikle uzun komut dosyalarÄ±nda hata ayÄ±klamak iÃ§in 
ve belirli hesaplamalarÄ±n bir dokumana yazÄ±lmak istediÄŸinde bu iÅŸlemleri bir nesneye atamadan yapabilmektedir. Asil amacÄ± komutlarÄ±n Ã§alÄ±ÅŸmasÄ±nÄ± hÄ±zlandÄ±rmaktadÄ±r.
- Ã‡alÄ±ÅŸma alanÄ±nÄ± temizleyerek aÅŸaÄŸÄ±daki kod satÄ±rlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m.


```r
 # Baglanti kurulmasi
 sink("sinktest.txt")
 
 # Islem yapilmasi
 x &lt;- matrix(rnorm(16),4,4)
 y &lt;- matrix(rnorm(16),4,4)
 x %*% y # sonuc konsolda gorunmez
 # islemin dosyaya yazdirilip kapatilmasi
 sink()
```

---

## dump() fonksiyonu
- **dump()** fonksiyonu ile bir R oturumu sÄ±rasÄ±nda kullanmak istenmeyen nesneler bir dosyaya yazdÄ±rabilir. 
- Bu sayede Ã§alÄ±ÅŸma alanÄ±nda yer kaplamazlar ve tekrar kullanÄ±lmak istenildiÄŸinde **source()** fonksiyonu ile kullanÄ±labilirler.

```r
 # x ve y nesnelerinin olusturulmasi
 x&lt;-matrix(rnorm(16),4,4)
 y&lt;-matrix(rnorm(16),4,4)
 
 # Bu nesnelerin metin seklinde bir dosyaya yazdirilmasi
 dump(c("x","y"), file="dumptest.txt")
```
- Ã§alÄ±ÅŸma alanÄ±nÄ±n temizlenmeyerek, **source()** fonksiyonu ile dosya Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda nesneler tekrar Ã§alÄ±ÅŸma alanÄ±na gelir.


```r
 source("dumptest.txt")
```


---

## dput() ve dget() fonksiyonlar?

- **dput()** fonksiyonunu ile saklanan nesneler  **dget()** fonksiyonu ile tekrar Ã§alÄ±ÅŸma alanÄ±na getirilebilir ve yeni bir nesneye atanabilir. 


- **dump()** fonksiyonu nesneyi aynÄ± iÅŸlemle Ã§alÄ±ÅŸma alanÄ±na getirirken,


- **dget()** fonksiyonu ise nesnenin iÃ§eriÄŸini yazdÄ±rÄ±r

- nesneyi  Ã§alÄ±ÅŸma alanÄ±na kaydetmek iÃ§in nesneye yeni bir ad vermek gerekmektedir.

 
--


```r
 # df nesnesinin dput() fonksiyonu ile dosyaya yazdirilmasi
 dput(df, file="dput.txt")
 #  calisma alaninin temizlenmesi
 rm(list=ls())
 # Veri setinin tekrar  calisma alanina getirilmesi
 yeni &lt;- dget("dput.txt")
 yeni 
```

```
##       ad boy kilo beden
## 1    Ali 160   50     S
## 2   Elif 165   55     M
## 3     Su 170   57     S
## 4  Deniz 155   50     M
## 5   Aras 167   48     S
## 6   Berk 162   65     L
## 7    Can 169   58     M
## 8    Ece 158   62     L
## 9    Efe 160   45     S
## 10  Arda 164   47     S
```
 
--


---

# file() fonksiyonlari


```r
 deneme&lt;-file("deneme.txt", open="w")
 
 # Dosyaya belirli satirlarin eklenmesi 
 cat("Bu bir denemedir\n\n", file=deneme)
 
 # Dosyaya yazdirilmak istenilen nesnenin olusturulmasi
 matris1&lt;-matrix(round(rnorm(12),4), ncol=3)
 
 # Nesnenin yazdirilmasi
 write.table(matris1, file=deneme, row.names=FALSE, col.names=FALSE)
 
 # kapatma
 close(deneme)
 
 # Ayni dosyaya tekrar ekleme yapilmasi
 matris2&lt;-matrix(round(rnorm(12),4), ncol=3)
 write.table(matris2, file="deneme.txt", 
             row.names=FALSE,  col.names=FALSE, append=TRUE)
```
 

 


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-light",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
