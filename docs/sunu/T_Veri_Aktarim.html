<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R ile Veri Analizi</title>
    <meta charset="utf-8" />
    <meta name="author" content="    👩‍🏫 Dr. Kübra ATALAY KABASAKAL   Hacettepe Üniversitesi" />
    <script src="libs/header-attrs-2.17/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="slides-style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R ile Veri Analizi
]
.subtitle[
## <br> 📉 Veri Aktarımı
]
.author[
### <br> <br> 👩‍🏫 Dr. Kübra ATALAY KABASAKAL <br> Hacettepe Üniversitesi
]
.date[
### <br> <br> <br> <br>📧 <a href="mailto:katalay@hacettepe.edu.tr" class="email">katalay@hacettepe.edu.tr</a>
]

---


## Veri Okuma



- Veri girişi istatistiksel analiz surecinin ilk adımıdır.

--

- R'da veri girişi diğer yazılımlarla kıyaslandığında çok kullanışlı değildir. 

--

- Bu nedenle aktarma/import yolu tercih edilir.

--

- Veri aktarımı için çok sayıda fonksiyon ve paket bulunmaktadır. 

--

- Ayrıca menü ile de aktarma yapılabilir. 

--

- Bilgisayardan internetten farklı formattaki veriler okunabilir.

---

# Veri Aktarımı
  
- Veri setleri genellikle Excel, SPSS veya metin dosyaları (.txt, .csv, .dat, vb.) gibi uygun veri biçimlerinde kaydedilir


- R, çeşitli veri formatlarını içe aktarabilir (yani okuyabilir).

--

Bir veri setini R'ye aktarmanın iki yolu vardır:

--

1. RStudio'da "Veri Kümesini İçe Aktar" menü seçeneğini kullanarak
2. Belirli bir R komutunu kullanarak

&lt;br/&gt;

---
## Yöntem 1: RStudio'yu Kullanma

  ![R studio](figs/importmenu.png)

---
### Excel dosylarını içe aktarma

* İçe aktarmak istediğiniz dosyaya göz atın.

* Veri seti için bir isim verin. 

* İçe aktarılacak sayfayı seçin.

* Değişken isimleri dosyanın ilk satırındaysa "First Row as Names".

![Excel dosylarını içe aktarma](figs/excel1.png)

---
### SPSS dosylarını içe aktarma

* İçe aktarmak istediğiniz dosyaya göz atın.

* Veri seti için bir isim verin. 

![SPSS dosylarını içe aktarma](figs/spss1.png)

&lt;br/&gt;

---
## Veri Okuma

-   En temel veri okuma/aktarma fonksiyonlari

--

    -   `scan()`
    
--

    -   `read.*`
    
--

    -   `read.table()`
    
--

    -   `read.csv()`
    
--

    -   `read.csv2()`
    
--

    -   `read.delim()`
    
--

    -   `read.delim2()`
    
--

    -   `readLines()`
    
---
## Veri Okuma


--

-   Verinin düzgün girilmiş olması okumayı kolaylaştırır.

--

-   İlk satırda genellikle değişken adlarına (header), 
ilk sütunda ise kimlik veya sıra numarasına yer verilir.

--

-   Gözlemlere ve değişkenlere ilişkin veri girilirken karakterler veya 
sayısal değerler arasında boşluk bırakmaktan kaçınmak gerekmektedir.

--

-   Değişken adı boşluklu yazılmışsa ne olur?

---
## Veri Okuma

--


-   Eksik veri boyunca aynı şekilde girilmelidir.

--


-   Değişkenlerin birinden nasıl ayrıldığı önemlidir. (, ; : \ / )

--


-   Tercihimiz **.csv** uzantılı veriler ama büyük veri setleri az yer kalması icin **.txt,.prn** formatında karşımıza çıkabilmektedir.

---
### Komutlarla veri aktarma
  
- Temel pakette **read.csv** ve **read.table** gibi bazı fonksiyonlar bulunmaktadır.

- Ayrıca, belirli  formatlarını içe aktarmak için R paketleri bulunmaktadır.

- Örneğin, SPSS dosyaları için **foreign** ve Excel dosyaları için **xlsx** gibi

---

## read.\*() fonksiyonlari
|  **Argüman**  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|   **Açıklama**	|
|:---	|:---	|
|  **header** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 	|  Mantıksal değerler ile verinin ilk satırında değişken isimlerinin olup olmadığını test eder. 	|
|  **sep**  	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  |  Sütun ayracıdır.  	|
|   **na.strings** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|  Kayıp değerleri belirtmek için kullanılır.  	|
|   **dec**	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  |  Ondalık sayıların ne ile ayrıldığını gösteren argümandır.  	|
|   **nrows** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 	|  Okunmak istenilen satır sayısını belirtmek için kullanılır.  	|
|   **skip**  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	|  Bir dosya okunurken okunmadan atlanmak istenilen satır sayısı için kullanılır.  |



---
## Importing Excel files
  

```r
# yükle ve aktive et 
install.packages("xlsx")
library("xlsx")

# read.xlsx fonksiyonunun kullanımı
my_excel_file &lt;- read.xlsx("dizin/dosyaadi.xlsx",
                 sheetName = "sheetname")
```

---
### SPSS dosyası aktarma
  

```r
# yükle ve aktive et 
install.packages("foreign")
library("foreign")

# read.spss fonksiyonunun kullanımı
my_spss_file &lt;- read.spss("dizin/dosyaadi.sav",
                to.data.frame = TRUE)
```


---
### text dosyası aktarma

- text dosyaları okumak için paket yüklemeye gerek yoktur.  

```r
# , ile ayrılmış csv dosyaları
csv_dosya &lt;- read.csv("dizin/dosyaadi.csv", 
                      header = TRUE)

# tab ile ayrılmış txt dosyaları
txt_dosya &lt;- read.table("dizin/dosyaadi.txt", h
                        header = TRUE, sep = "\t")
```

- Dikkat
  
- `header = TRUE` 
- `sep="\t"` 
- `sep=","` for comma-separated files

---
## Uygulama

- 🔗[veri1.txt](import/veri1.txt)
- 🔗[veri1.csv](import/veri1.csv)
- 🔗[verifwf.txt](import/fwf.txt)
- 🔗[factor.sav](import/factor.sav)
- 🔗
[https://www.statmodel.com/usersguide/chap3/ex3.1.dat](https://www.statmodel.com/usersguide/chap3/ex3.1.dat)

---
## Uygulama



---
## Veri Yazma


```r
ad  &lt;-  c("Ali","Elif","Su","Deniz","Aras","Berk","Can","Ece","Efe","Arda")
boy &lt;- c(160,165,170,155,167,162,169,158,160,164)
kilo &lt;- c(50,55,57,50,48,65,58,62,45,47)
beden &lt;- c("S","M","S","M","S","L","M","L","S","S")
df &lt;- data.frame(ad, boy, kilo, beden)
df
```

```
##       ad boy kilo beden
## 1    Ali 160   50     S
## 2   Elif 165   55     M
## 3     Su 170   57     S
## 4  Deniz 155   50     M
## 5   Aras 167   48     S
## 6   Berk 162   65     L
## 7    Can 169   58     M
## 8    Ece 158   62     L
## 9    Efe 160   45     S
## 10  Arda 164   47     S
```

---

## write.table 

--


```r
write.table(df, file="df.txt")# df dosyasi nerede, gorunumu nasil
```

--


```r
write.table(df, file="df.txt",row.names = FALSE,col.names = FALSE)
# karakter nesnler tirnak icinde ne yapmali?
```

--


```r
write.table(df, file="df.txt",row.names = FALSE,col.names = FALSE,quote=FALSE)
```

---

## write.table 

yeni gözlem eklemek istiyorsaniz append argümanı kullanılabilir.


```r
 ek &lt;- data.frame(ad=c("Ahmet","Ali"), boy=c(180,170), kilo=c(60,70), 
                 beden=c("S","L"))
```

--


```r
write.table(ek, "df.txt",row.names=FALSE,
            col.names=FALSE,
            quote=FALSE,append=TRUE)
```

---

## write.csv

**write.csv()** fonksiyonu kullanılarak yazılan veri dosyaları "," ile,   **write.csv2()**  fonksiyonu kullanılarak yazılan veri dosyaları ise ";" ile ayrılır  iki fonksiyonun bir diğer farkı ise ondalık sayı ayıracıdır.

--

 write.csv ile yazdırılan dosyaların excelde açılması


---

## cat

**cat()** fonksiyonu

- Döngülerde sıklıkla ekrana bilgi yazdırmak amacıyla kullanılır, ancak dosya yazdırmak amacıyla da kullanabilmektedir. 
- fonksiyonlarla yapılan hesaplama çıktısı da yazabilmektedir. 
- Bu nedenle bir R oturumu sırasında not alınmak istenilen bilgileri bir dosyaya yazdırmak için kullanılabilir.


```r
 cat("ogrencilerin boy ortalamasi ", mean(boy), "\n",
      "ogrencilerin kilo ortalamasi", mean(kilo), "\n",
     file="bilgi.txt")
```
 **"\n" ne ise yaradi?**
 
---
## writeLines fonksiyonu

```r
writeLines("ogrencilerin boy ortalamasi: 163 cm\n",
            "ogrencilerin kilo ortalamasi: 53.7 kg",
            con="bilgi2.txt")
```

 
---
 
## sink() fonksiyonu

- **sink()**  fonksiyonu yapılan işlemlerin çıktısını R konsola değil belirtilen dosyaya yazmaktadır. Bu fonksiyon özellikle uzun komut dosyalarında hata ayıklamak için 
ve belirli hesaplamaların bir dokumana yazılmak istediğinde bu işlemleri bir nesneye atamadan yapabilmektedir. Asil amacı komutların çalışmasını hızlandırmaktadır.
- Çalışma alanını temizleyerek aşağıdaki kod satırlarını çalıştıralım.


```r
 # Baglanti kurulmasi
 sink("sinktest.txt")
 
 # Islem yapilmasi
 x &lt;- matrix(rnorm(16),4,4)
 y &lt;- matrix(rnorm(16),4,4)
 x %*% y # sonuc konsolda gorunmez
 # islemin dosyaya yazdirilip kapatilmasi
 sink()
```

---

## dump() fonksiyonu
- **dump()** fonksiyonu ile bir R oturumu sırasında kullanmak istenmeyen nesneler bir dosyaya yazdırabilir. 
- Bu sayede çalışma alanında yer kaplamazlar ve tekrar kullanılmak istenildiğinde **source()** fonksiyonu ile kullanılabilirler.

```r
 # x ve y nesnelerinin olusturulmasi
 x&lt;-matrix(rnorm(16),4,4)
 y&lt;-matrix(rnorm(16),4,4)
 
 # Bu nesnelerin metin seklinde bir dosyaya yazdirilmasi
 dump(c("x","y"), file="dumptest.txt")
```
- çalışma alanının temizlenmeyerek, **source()** fonksiyonu ile dosya çalıştırıldığında nesneler tekrar çalışma alanına gelir.


```r
 source("dumptest.txt")
```


---

## dput() ve dget() fonksiyonlar?

- **dput()** fonksiyonunu ile saklanan nesneler  **dget()** fonksiyonu ile tekrar çalışma alanına getirilebilir ve yeni bir nesneye atanabilir. 


- **dump()** fonksiyonu nesneyi aynı işlemle çalışma alanına getirirken,


- **dget()** fonksiyonu ise nesnenin içeriğini yazdırır

- nesneyi  çalışma alanına kaydetmek için nesneye yeni bir ad vermek gerekmektedir.

 
--


```r
 # df nesnesinin dput() fonksiyonu ile dosyaya yazdirilmasi
 dput(df, file="dput.txt")
 #  calisma alaninin temizlenmesi
 rm(list=ls())
 # Veri setinin tekrar  calisma alanina getirilmesi
 yeni &lt;- dget("dput.txt")
 yeni 
```

```
##       ad boy kilo beden
## 1    Ali 160   50     S
## 2   Elif 165   55     M
## 3     Su 170   57     S
## 4  Deniz 155   50     M
## 5   Aras 167   48     S
## 6   Berk 162   65     L
## 7    Can 169   58     M
## 8    Ece 158   62     L
## 9    Efe 160   45     S
## 10  Arda 164   47     S
```
 
--


---

# file() fonksiyonlari


```r
 deneme&lt;-file("deneme.txt", open="w")
 
 # Dosyaya belirli satirlarin eklenmesi 
 cat("Bu bir denemedir\n\n", file=deneme)
 
 # Dosyaya yazdirilmak istenilen nesnenin olusturulmasi
 matris1&lt;-matrix(round(rnorm(12),4), ncol=3)
 
 # Nesnenin yazdirilmasi
 write.table(matris1, file=deneme, row.names=FALSE, col.names=FALSE)
 
 # kapatma
 close(deneme)
 
 # Ayni dosyaya tekrar ekleme yapilmasi
 matris2&lt;-matrix(round(rnorm(12),4), ncol=3)
 write.table(matris2, file="deneme.txt", 
             row.names=FALSE,  col.names=FALSE, append=TRUE)
```
 

 


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-light",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
